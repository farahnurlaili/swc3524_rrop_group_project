import java.util.*;

public class MaritimeReliefRouteOptimization {

    static int[][] distanceMatrix = {
        {0, 15, 25, 35}, 
        {15, 0, 30, 28}, 
        {25, 30, 0, 20}, 
        {35, 28, 20, 0}  
    };

    static String[] locations = {"Port A", "Port B", "Relief Center C", "Relief Center D"};
    
    public static String greedyTSP(int[][] distanceMatrix) {
        int N = distanceMatrix.length;
        if (N <= 1) {
            return "Total Distance: 0 nm (Needs more than one city)";
        }

        boolean[] visited = new boolean[N];
        ArrayList<Integer> route = new ArrayList<Integer>();
        
        int currentCity = 0;
        int totalDistance = 0;
        
        route.add(currentCity);
        visited[currentCity] = true;

        while (route.size() < N) {
            int minDistance = Integer.MAX_VALUE;
            int nextCity = -1;

            for (int neighbor = 0; neighbor < N; neighbor++) {
                if (visited[neighbor] == false) {
                    int distance = distanceMatrix[currentCity][neighbor];
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nextCity = neighbor;
                    }
                }
            }

            if (nextCity != -1) {
                totalDistance = totalDistance + minDistance;
                currentCity = nextCity;
                visited[currentCity] = true;
                route.add(currentCity);
            } else {
                break;
            }
        }

        int lastCity = route.get(route.size() - 1);
        int startCity = route.get(0);
        
        int returnDist = distanceMatrix[lastCity][startCity];
        totalDistance = totalDistance + returnDist; 
        route.add(startCity);

        String output = "Greedy Route: ";
        for (int i = 0; i < route.size(); i++) {
            output = output + locations[route.get(i)];
            if (i < route.size() - 1) {
                output = output + " -> ";
            }
        }
        
        output = output + " | Distance: " + totalDistance + " nm";

        return output;
    }
    
    private static ArrayList<Integer> bestRoute = new ArrayList<>();
    private static int minDistance = Integer.MAX_VALUE; 

    public static String bruteForceTSP(int[][] distanceMatrix) {
        int N = distanceMatrix.length;
        if (N <= 1) {
            return "Total Distance: 0 nm (Needs more than one city)";
        }

        minDistance = Integer.MAX_VALUE; 
        bestRoute.clear(); 

        int startCity = 0;
        
        boolean[] visited = new boolean[N];
        visited[startCity] = true;
        
        ArrayList<Integer> currentRoute = new ArrayList<Integer>();
        currentRoute.add(startCity);
        
        recurseFindRoute(distanceMatrix, N, startCity, visited, currentRoute, 0);

        if (bestRoute.isEmpty()) {
            return "Brute Force Route: Could not find path.";
        }
        
        String output = "Brute Force Route: ";
        for (int i = 0; i < bestRoute.size(); i++) {
            output = output + locations[bestRoute.get(i)];
            if (i < bestRoute.size() - 1) {
                output = output + " -> ";
            }
        }
        
        output = output + " | Distance: " + minDistance + " nm (Optimal)";

        return output;
    }

    private static void recurseFindRoute(
        int[][] distanceMatrix, 
        int N, 
        int currentCity, 
        boolean[] visited, 
        ArrayList<Integer> currentRoute, 
        int currentDistance
    ) {
        if (currentRoute.size() == N) {
            int finalDist = currentDistance + distanceMatrix[currentCity][0];

            if (finalDist < minDistance) {
                minDistance = finalDist;
                bestRoute.clear();
                bestRoute.addAll(currentRoute);
                bestRoute.add(0); 
            }
            return;
        }

        for (int nextCity = 0; nextCity < N; nextCity++) {
            if (visited[nextCity] == true) {
                continue;
            }
            
            visited[nextCity] = true;
            currentRoute.add(nextCity);
            int newDistance = currentDistance + distanceMatrix[currentCity][nextCity];

            recurseFindRoute(distanceMatrix, N, nextCity, visited, currentRoute, newDistance);
            
            currentRoute.remove(currentRoute.size() - 1);
            visited[nextCity] = false;
        }
    }
    

    public static void main(String[] args) {
        System.out.println("--- Greedy Algorithm ) ---");
        String greedyResult = greedyTSP(distanceMatrix);
        System.out.println(greedyResult);
        System.out.println();
        String bruteForceResult = bruteForceTSP(distanceMatrix);
        System.out.println(bruteForceResult);
    }
}
