import java.util.*;

public class DynamicAlgorithm {

    // Distance Matrix (Adjacency Matrix)
    static int[][] distanceMatrix = {
        {0, 15, 25, 35}, 
        {15, 0, 30, 28}, 
        {25, 30, 0, 20}, 
        {35, 28, 20, 0} 
    };

    // Location names
    static String[] locations = {"Port A", "Port B", "Relief Center C", "Relief Center D"}; 
    
    // Global Configuration (Used throughout the DP functions)
    static final int N = locations.length; // Number of cities (4)
    static final int START_NODE = 0; // Index of the starting and ending port (Port A)

    public static String dynamicProgrammingTSP(int[][] dist) {
        // Calculate the state where ALL cities have been visited.
        final int VISITED_ALL = (1 << N) - 1; 
        
        // 1. Memoization Table (Cost Cache):
        int[][] memo = new int[1 << N][N];
        
        // 2. Path Tracking Table (Next Step Cache):
        // Stores the NAME of the optimal next city to visit from the state (mask, pos).
        String[][] paths = new String[1 << N][N]; 
        
        // Initialize memoization table with -1 (indicating 'uncalculated' state)
        for (int[] row : memo) Arrays.fill(row, -1);
        
        // Start the recursive search from START_NODE (Port A).
        // Initial mask is 1 << START_NODE, meaning only the starting city has been visited (binary 0001).
        int minTotalCost = dynamicProgrammingTSPHelper(START_NODE, 1 << START_NODE, dist, memo, VISITED_ALL, paths);
        
        // --- Path Reconstruction (Building the final sequence) ---
        
        StringBuilder path = new StringBuilder(locations[START_NODE]);
        int currentPos = START_NODE;
        int mask = 1 << START_NODE;
        
        // Loop until the mask shows all cities have been visited
        while(mask != VISITED_ALL) {
            // Look up the name of the BEST next city from our paths table
            String nextLocationName = paths[mask][currentPos];
            
            // Find the index of that best next city
            int nextPos = -1;
            for(int i = 0; i < N; i++) {
                if (locations[i].equals(nextLocationName)) {
                    nextPos = i;
                    break;
                }
            }
            
            // If the next position is found, move to that city and update the mask
            if (nextPos != -1) { 
                path.append(" -> ").append(locations[nextPos]);
                currentPos = nextPos;
                // Bitwise OR (|) operator: Adds the new city (1 << nextPos) to the mask
                mask |= (1 << nextPos); 
            } else {
                break; 
            }
        }
        
        // Final return trip to the starting port
        path.append(" -> ").append(locations[START_NODE]);
        
        // Format the output exactly as requested
        return String.format("Dynamic Programming TSP Route: %s | Total Distance: %d nm", path.toString(), minTotalCost);
    }

    private static int dynamicProgrammingTSPHelper(int pos, int mask, int[][] dist, int[][] memo, final int VISITED_ALL, String[][] paths) {
        
        // Base Case: If the current mask matches the VISITED_ALL mask (all cities reached)
        if (mask == VISITED_ALL) {
            // We must now return to the START_NODE (Port A) to complete the cycle.
            return dist[pos][START_NODE]; 
        }
        
        // Memoization Check: If the result for this specific state (mask and pos)
        // has already been calculated and stored, return it immediately.
        if (memo[mask][pos] != -1) {
            return memo[mask][pos];
        }
        
        int minCost = Integer.MAX_VALUE;
        String nextBestLocation = "";

        // Loop through all possible next cities ('next')
        for (int next = 0; next < N; next++) {
            
            // Bitmask Check: Check if the 'next' city is UNVISITED.
            // (1 << next) creates a number with only the 'next' bit set (e.g., 0010 for city 1).
            // If the bitwise AND (&) result is 0, the city is not in the mask yet.
            if ((mask & (1 << next)) == 0) {
                
                // 1. Calculate the cost to travel from 'pos' to 'next'.
                // 2. Recursively find the optimal cost from 'next' with the new mask 
                //    (mask | (1 << next) -> mask with 'next' city added).
                int costToNext = dist[pos][next];
                int optimalRemainingCost = dynamicProgrammingTSPHelper(next, mask | (1 << next), dist, memo, VISITED_ALL, paths);
                
                int newTotalCost = costToNext + optimalRemainingCost;
                
                // If this path is better than the current minimum, update minCost
                if (newTotalCost < minCost) {
                    minCost = newTotalCost;
                    nextBestLocation = locations[next];
                }
            }
        }
        
        // Before returning, store the result in the memoization table (caching).
        memo[mask][pos] = minCost;
        // Also store the optimal next step for path reconstruction later.
        paths[mask][pos] = nextBestLocation;
        
        return minCost;
    }

    public static void main(String[] args) {
        System.out.println("--- Maritime Relief Route Optimization (Dynamic Programming) ---");
        System.out.println("Locations: " + Arrays.toString(locations));
        System.out.println();
        
        // Execute the Dynamic Programming TSP
        String result = dynamicProgrammingTSP(distanceMatrix);
        System.out.println(result);
    }
}
